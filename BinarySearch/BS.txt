binary search는 완전탐색으로 풀었을 때 시간복잡도가 너무 클 때 사용하거나 최적화문제를 결정문제로 변환하는데 사용할 수 있다.
최적화문제를 결정문제로 변환한다는 것은 값을 변경해가면서 조건에 맞는지 테스트를 해보는 것이다.

BS1.cpp
BOJ 2776 암기왕
매 테스트케이스마다 벡터를 초기화해줘야함.
중간값과 같으면 return 1.작으면 start부터 mid-1까지 크면 mid+1부터 end까지.

#BS2.cpp 
BOJ 2792 보석상자
이게 어떻게 Binary Search 문제인지?

질투심이란 한 학생이 가질 수 있는 최대 보석의 개수. 
추가 조건으로 한 학생은 같은 종류의 보석만 가질 수 있음.
문제에서는 질투심을 가장 최소로 하기를 요구.
탐색 알고리즘으로는 완전탐색, 백트래킹 등이 있지만 이 문제에서는 학생의 수가 십억.
탐색을 해야하는 수가 이렇게 클 경우 시간복잡도를 줄여하 함. 
이분탐색을 이용해서 log2n으로 줄일 수 있음.

처음에 어떻게 접근했는지? 보석의 개수 m이 주어지면 m번만큼 보석을 n명의 학생에 게 나눠주고 각 학생이 가질 수 있는 보석의 최대개수를 갱신하는 것으로 접근했으나,
이 접근은 한 학생이 한 보석만 가질 수 있다는 조건을 놓쳐 틀린 접근이다.

그래서 어떻게?
질투심을 t라고 했을 때 학생들이 t인 질투심을 가지고 모두 나눠가질 수 있는지로 접근한다. t를 못가진다면 t를 늘리고 t를 가진다면 t를 줄이다. 늘리고 줄일 때 이분탐색을 사용한다.

// 1. 0으로 나누는 것 조심. 애초에 0으로 나눠지지 않도록 세팅해야. 그래서 l의 초기값이 1.
// 2. binary search할때 l<r으로해야하는지 l<r로 해야하는지? : 
/*
조건	while (l < r)	while (l <= r)
목적	특정 조건을 만족하는 첫 위치 찾기 (lower/upper bound)	값이 존재하는지 확인
탐색 종료 조건	l == r	l > r
mid값 포함 여부	r = mid (mid 포함)	r = mid - 1 (mid 제외)
결과	l 또는 r이 원하는 값	값이 존재하면 mid, 없으면 추가 처리 필요
*/