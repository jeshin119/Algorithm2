dp1
백준 1463번.
dp 또는 bfs로 가능.
완전탐색을 돌리지 않고(bfs를 안하고) dp를 통해 이전에 기억한 값들을 가져와 쉽게 구할 수 있음.
if if 문인지 if else if 문인지 구별해야함

/3를 할건지 /2를 할건지 -1를 할건지, 3가지의 경우의 수의 최소값을 구해야하기 때문에 모두 구해야 함.
일단 값을 대입하고 대입한 값과 비교 연산을 하는 과정에서 dp를 활용할 수 있음.

dp2
백준 9095번
점화식문제
점화식이 잘 안떠오른 이유는 애초에 초기값을 잘못 생각했기 때문에.
인덱스 연산이 헷갈리는 경우는 배열의 0번째는 빼고 1번째부터 사용하자.

dp3
백준2579번 계단오르기
완전탐색이 먼저 떠오르는데 dp보단.. 근데 n, 계단의 개수가 300정도로 큰 경우 완전탐색을 고려하기엔 시간복잡도 때문에 어려울 것 같음.
완전탐색으로는 백트래킹 dfs,bfs가 있음. 이것또한 다시 공부할 것.
그래도 dp를 사용하려면, 기록하면서 진행하기 또는 점화식을 사용해야함.

인덱스 연산 0부터 시작하는 것과 숫자연산 1부터 개수로 시작하는게 헷갈림
결과 출력하는 것도 인덱스연산으로 통일할거면 n-1이 마지막이므로 그것을 알아야하는데
마지막을 n으로 생각해서 밑에와 같은 식으로 출력을했음. 	cout << m-min(d[n-2],d[n-3]);
이걸 찾으려니까 잘 안찾아짐. 애초에 아예 숫자로 접근할건지 인덱스로 접근할건지 통일을 먼저하는게 좋을듯.

dp4
백준 1149 rgb색칠하기
점화식을 세우기위해서 먼저 dp[]또는 dp[][]를 먼저 정의하는게 필요.
이 문제에서는 현재 집에 rgb를 색칠하기 위해서 이전값과 달라야 한다는 조건이 있음. 
그리디는 최적화가 되지 않으므로 당연히 고려하기 어렵고
그래서 각 집(칠해야할 대상)마다 rgb 세 케이스를 모두 고려해 기록하면서 진행할 수 있음.

dp5
백준 11726 2xn타일링
디피를 사용할거면 정의먼저 D[i]의 정의. 그리고 D[i-1], D[i-2]의 정의를 생각하며 규칙을 찾는다
하나씩해보면서 수에서 규칙을 찾기보단. 형태와 미리 정한 정의를 생각하고 접근해야한다.
int형 오버플로우가 난다면? unsigned나 long을 사용하고 또는 교환법칙이 가능하면 먼저 나누기나 모듈러연산을 진행한다.

dp6
백준11659번 구간합구하기4
시간초과를 생각 왜안하는지. 만약에 들어온대로 숫자 다 받고 나서 각 누적합을 구하면 시간복잡도가 O(NM)이 되므로 다른 방법이 필요.
누적합을 미리 구해놓는다면 N의 반복을 하면서 필요할 땐 바로 접근해서 사용가능.
	
dp7
백준12852번 1로만들기2
최소값을 구하는 것뿐만아니라 경로까지 기억해야함. 
경로를 기억하는 건 따로 공간을 만들어서 최소값을 구하는 경로의 인덱스를 타고들어가면서 반환하면됨.
if else elseif 문을 사용하면 덮어쓰기가 불가능.
일단 값을 넣고 비교해서 작으면 overwrite하고 또 비교해서 작으면 overwrite하고 이런 방식으로 코드를 줄일 수 있음. 
if문만 연달아 사용하면 됨.

boj2240
자두나무
dp->완탐+메모리제이션. 기저사례, 메모리제이션, 로직, 초기화.
완탐인데 시간초과걸릴거같으면 DP사용. 완탐인데 중복되는 가지 및 로직이 있다? DP사용.
바텁업, 탑다운. 탑다운은 필요한 것만 구함. e.g. boj2240 자두나무. 바텀업은 모두 다 구해놓음. e.g. 15989 1,2,3,더하기 4.

boj15989 1,2,3더하기 4.
DP바텁업. 점화식. 초기값도 로직이 적용되게끔.