dp잘하려면:
1. 문제를 잘 정의.
2. 부분 문제들의 관계를 파악
----------------------------------

dp를 사용하기 위한 조건:
1. 참조 투명성을 가져야 함.
: 입력이 같으면 같은 결과를 가져야 함.

2. Overlapping subproblem을 가져야함.
: 이미 계산한 값을 사용한다는 점에서 유리해야 함.

3. Optimal substructure
: 어떤 문제의 최적해가 그 부분문제들의 최적해로 구성될 수 있어야 한다.
부분 문제의 최적해가 전체 문제의 최적해를 보장-> 그리디 사용 가능
과거 선택이 이후의 선택에 영향을 미쳐서 최적해가 바뀔 수 있을 때 -> DP

4. Directed Acyclic graph 구조를 가져야 함. (일반적으로)
: 방향성이 있고 사이클이 없는. DP 상태전이가 순환구조를 가지면 무한루프에 빠질 수 있음.
----------------------------------

구현: 
1. 기저사례
2. 메모리제이션
3. 로직
4. 초기화
----------------------------------

boj15989 1,2,3더하기 4.
1. 로직과 메모리제이션을 어떻게 구성할건지. 
2. 겹치는 부분이 있는지.
3. 쪼개서 생각할 수 있는지.
----------------------------------

boj 2098 외판원 순회
1. 순서가 상관 없다는 것을 알아야 가능.
2. 시작도 상관 없다는 것을 알아야 가능.
3. 다차원배열을 비트마스킹으로 해결할 수 있어야.
4. dp배열이 방문한 정점들을 순회한 최소값이라고 정의. 순서를 달리한 경우의 수를 모두 탐색해야 한다. 때문에 1<<MAXN을 사용.
----------------------------------

boj 17070 파이프구하기
1. 경우의수? 더하기!

----------------------------------

dp1
백준 1463번.
dp 또는 bfs로 가능.
완전탐색을 돌리지 않고(bfs를 안하고) dp를 통해 이전에 기억한 값들을 가져와 쉽게 구할 수 있음.
if if 문인지 if else if 문인지 구별해야함

/3를 할건지 /2를 할건지 -1를 할건지, 3가지의 경우의 수의 최소값을 구해야하기 때문에 모두 구해야 함.
일단 값을 대입하고 대입한 값과 비교 연산을 하는 과정에서 dp를 활용할 수 있음.

dp2
백준 9095번
점화식문제
점화식이 잘 안떠오른 이유는 애초에 초기값을 잘못 생각했기 때문에.
인덱스 연산이 헷갈리는 경우는 배열의 0번째는 빼고 1번째부터 사용하자.

dp3
백준2579번 계단오르기
완전탐색이 먼저 떠오르는데 dp보단.. 근데 n, 계단의 개수가 300정도로 큰 경우 완전탐색을 고려하기엔 시간복잡도 때문에 어려울 것 같음.
완전탐색으로는 백트래킹 dfs,bfs가 있음. 이것또한 다시 공부할 것.
그래도 dp를 사용하려면, 기록하면서 진행하기 또는 점화식을 사용해야함.

인덱스 연산 0부터 시작하는 것과 숫자연산 1부터 개수로 시작하는게 헷갈림
결과 출력하는 것도 인덱스연산으로 통일할거면 n-1이 마지막이므로 그것을 알아야하는데
마지막을 n으로 생각해서 밑에와 같은 식으로 출력을했음. 	cout << m-min(d[n-2],d[n-3]);
이걸 찾으려니까 잘 안찾아짐. 애초에 아예 숫자로 접근할건지 인덱스로 접근할건지 통일을 먼저하는게 좋을듯.

dp4
백준 1149 rgb색칠하기
점화식을 세우기위해서 먼저 dp[]또는 dp[][]를 먼저 정의하는게 필요.
이 문제에서는 현재 집에 rgb를 색칠하기 위해서 이전값과 달라야 한다는 조건이 있음. 
그리디는 최적화가 되지 않으므로 당연히 고려하기 어렵고
그래서 각 집(칠해야할 대상)마다 rgb 세 케이스를 모두 고려해 기록하면서 진행할 수 있음.

dp5
백준 11726 2xn타일링
디피를 사용할거면 정의먼저 D[i]의 정의. 그리고 D[i-1], D[i-2]의 정의를 생각하며 규칙을 찾는다
하나씩해보면서 수에서 규칙을 찾기보단. 형태와 미리 정한 정의를 생각하고 접근해야한다.
int형 오버플로우가 난다면? unsigned나 long을 사용하고 또는 교환법칙이 가능하면 먼저 나누기나 모듈러연산을 진행한다.

dp6
백준11659번 구간합구하기4
시간초과를 생각 왜안하는지. 만약에 들어온대로 숫자 다 받고 나서 각 누적합을 구하면 시간복잡도가 O(NM)이 되므로 다른 방법이 필요.
누적합을 미리 구해놓는다면 N의 반복을 하면서 필요할 땐 바로 접근해서 사용가능.
	
dp7
백준12852번 1로만들기2
최소값을 구하는 것뿐만아니라 경로까지 기억해야함. 
경로를 기억하는 건 따로 공간을 만들어서 최소값을 구하는 경로의 인덱스를 타고들어가면서 반환하면됨.
if else elseif 문을 사용하면 덮어쓰기가 불가능.
일단 값을 넣고 비교해서 작으면 overwrite하고 또 비교해서 작으면 overwrite하고 이런 방식으로 코드를 줄일 수 있음. 
if문만 연달아 사용하면 됨.
