/*
***************************************************
1. boj 2618. 경찰차. 8-A
틀림.
11:18~12:46

---------------------------------------------------
생각한 점:
1. bfs로 때리면 되나? 가중치가 같으니까? 시간복잡도가 그러면 10^9가 되나? 

2. 최단거리를 사용하려면 다익스트라, 플로이드 워셜, bitindextree인데 이 셋 중에 사용할 수 있는게 있나? : 일단 플로이드 워셜 안되고 i->j가  i->k->j인지를 판별해야하는게 아니니까, bitindextree도 안될거같고 동적배열 누적합이 아니니까, 다익스트라는 뭐였지 priority queue사용해서 그리디형식으로 해서 dp를 갱신하는거지 이것도아닌거같은데..왜냐면 가중치가 같으니까.

3. 그러면 bfs로 하되, 시간복잡도를 줄여야한다는거같은데 블록으로 해서 범위를 지정해주는걸로.
:그러면 코드가 존나 길거나 다음 노드가 사방면중 어디인지 판별해야하는데..이거맞나?

4. 팬윅트리를 이차원배열에 적용할수있나? 안될거같은데

---------------------------------------------------
참고:
1. bfs를 왜 사용했는지? 가중치가 같은 최단거리니까. 하지만 최단거리는 두 좌표만으로도 알수있지 않는지?

2. 그리디로 풀면 틀림. 왜냐면 현재의 최단거리가 전체의 최단거리합의 일부가되는 보장이 없기때문에.

3. 경우의 수를 판단해야해서 dp를 사용.

4. dp에서 상태 재사용이 가능한지? 
: 정의를 생각. dp가 이전 경로를 어떻게 타고왔는지 상관없이 남은 사건들의 최단경로 최소합을 의미하므로 상태 재사용이 가능.
e.g.
    if(dp[a][b])
        return dp[a][b];

5. 종료조건이 왜 if (a==w+1 || b==w+1)인지?
: a는 경찰차1이 처리한 마지막 사건번호. b는 경찰차2가처리한 마지막 사건번호.
사건은 w개. 2~w+1까지. 따라서 a또는 b가 w+1이라면 마지막 사건을 처리했다는 것이므로 종료해야함.

6. dp는 어떻게 하고 trace는 어떻게할건지?
*/
===================================================